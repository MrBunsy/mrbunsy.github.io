<html><head>





<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Director Online Article: The Physics of an Elastic Collision (Part 2)</title>

<link rel="STYLESHEET" href="collison%20equations%20in%202d_files/doug.css" type="text/css"></head><body alink="#425294" bgcolor="#ffffff" link="#425294" text="#000000" vlink="#31427b">


<center>
<table width="792"><tbody><tr><td>

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr>
<td background="collison%20equations%20in%202d_files/dougmenu-left.gif" height="132" width="360">&nbsp;</td>
<td background="collison%20equations%20in%202d_files/dougmenu-middle.gif" height="132" width="432">

<table border="0" cellpadding="2" cellspacing="0">
<tbody><tr><td valign="top" width="100">
<span class="dougmenuhead">Articles</span><br>
<a href="http://director-online.com/listArticles.php?type=recent&amp;num=10" class="dougmenulink">Latest</a><br>
<a href="http://director-online.com/archive.php" class="dougmenulink">Archive</a><br>
<a href="http://director-online.com/search.php" class="dougmenulink">Search</a><br>

</td><td valign="top" width="100">
<span class="dougmenuhead">Community</span><br>
<a href="http://director-online.com/forums/" class="dougmenulink">Forums</a><br>
<a href="http://director-online.com/dougwiki/" class="dougmenulink">Wiki</a><br>
<a href="http://director-online.com/jobs.php" class="dougmenulink">Job Board</a><br>

</td><td valign="top" width="100">
<span class="dougmenuhead">Resources</span><br>
<a href="http://director-online.com/help.php" class="dougmenulink">Help Central</a><br>
<a href="http://director-online.com/lingo.php" class="dougmenulink">Lingo Database</a><br>
<a href="http://director-online.com/books.php" class="dougmenulink">Bookstore</a><br>
<a href="http://director-online.com/resources.php" class="dougmenulink">Links</a><br>



</td><td valign="top" width="100">
<span class="dougmenuhead">More</span><br>
<a href="http://director-online.com/index.php" class="dougmenulink">Main Menu</a><br>
<a class="dougmenulink" href="http://www.dpbolvw.net/click-2407477-10450380">Store</a><img src="collison%20equations%20in%202d_files/image-2407477-10450380.htm" border="0" height="1" width="1"><br>
<a href="http://director-online.com/contact.php" class="dougmenulink">About</a><br>
</td></tr></tbody></table>

</td>
<td background="collison%20equations%20in%202d_files/dougmenu-right.gif" height="120" width="18">&nbsp;</td>
</tr>
</tbody></table>
<p style="margin: 6px;" align="center">
</p><center>

<script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("http://clevermedia.net/phpadsnew/adjs.php?n=" + phpAds_random);
   document.write ("&amp;what=zone:3");
   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referer)
      document.write ("&amp;referer=" + escape(document.referer));
   document.write ("'><" + "/script>");
//-->
</script><script language="JavaScript" type="text/javascript" src="collison%20equations%20in%202d_files/adjs.js"></script><script type="text/javascript"><!--
google_ad_client = "pub-4838499138820524";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_channel ="7249946224";
//--></script>
<script type="text/javascript" src="collison%20equations%20in%202d_files/show_ads.js">
</script><iframe name="google_ads_frame" src="collison%20equations%20in%202d_files/ads.htm" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" frameborder="0" height="60" scrolling="no" width="468"></iframe><div id="beacon_8" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="collison%20equations%20in%202d_files/adlog.gif" alt="" style="width: 0px; height: 0px;" height="0" width="0"></div><noscript><a
href='http://clevermedia.net/phpadsnew/adclick.php?n=a0d437bb'
target='_blank'><img
src='http://clevermedia.net/phpadsnew/adview.php?what=zone:3&amp;n=a0d437bb'
border='0' alt=''></a></noscript>
<p></p><hr>
<a class="dougmenulink" href="http://www.dpbolvw.net/click-2407477-10450380" target="_top">Find all current special offers on Adobe products.</a>
<img src="collison%20equations%20in%202d_files/image-2407477-10450380.htm" border="0" height="1" width="1"> --
<a class="dougmenulink" href="http://www.tkqlhce.com/click-2407477-10469544" target="_top">Order Flash Creative Suite 3.</a>
<img src="collison%20equations%20in%202d_files/image-2407477-10469544.htm" border="0" height="1" width="1">



</center>
</td></tr>
<tr><td style="padding: 10px;">


<center>
<p><table border="0" cellpadding="0" cellspacing="0" width="95%">
<tbody><tr><td valign="top">

<p>
<font color="#4a5284" face="Verdana, Arial, Geneva, Helvetica, sans-serif" size="+2"><b> The Physics of an Elastic Collision (Part 2) </b></font></p>

<p><font size="-1">
<a href="http://director-online.com/listArticles.php?type=author&amp;author=Raman+Pfaff">by</a> <a href="mailto:pfaff@explorescience.com">Raman Pfaff</a></font></p>


<table border="0" cellpadding="0" cellspacing="0" width="500">
<tbody><tr> 
    
<td valign="top">

<p>
Predicting the future has always been a valued commodity ranging from foreseeing when a
drought would occur in agrarian times, to when a stock price will skyrocket in the digital
age. Physics is a fascinating science since it lets us do more than just predict the future,
we can actually determine the future. In <a href="http://director-online.com/buildArticle.cfm?id=460">Part 1 of this article</a> we learned how to determine
the future of two masses moving toward each other. If we know the masses and velocities of two
blocks, we used an equation to solve for the velocities in the future (after the collision).
Before going any further, I strongly urge you read Part 1 of this article where we learned
about many things, including vectors, momentum, and conservation of momentum.

</p><h4><font color="#cc0000" face="Verdana, Arial, Geneva, Helvetica, sans-serif">The 2D World</font></h4>

<p>
Part 1 of this article taught us the fundamentals of elastic collisions, but as I pointed out,
there were a few things that we still need to learn about. One of the most important issues is
dealing with the collision angle. The collision angle is the angle made by drawing a line
between the center of the two colliding objects (we'll only deal with round things in this
article). In a head-on collision the line connecting two objects is horizontal, so that
corresponds to an angle of zero degrees. That is rarely the case in the real world. Three
cases of colliding objects are shown in the simulation below (think of the simulation as
viewing billiard balls from above the table, with the red line showing the current angle
between the objects). In Case 1 the blue ball will barely graze the green one, in Case 2 the
blue one will strike a bit more cleanly, and in Case 3 you have a head on collision. Before
starting each simulation, can you guess what the result might be? Thinking about what happens
when playing pool can lead to great insight.

</p><p>
<div embedsrc="howTo/UD_articles/UD105/UD105.dcr" style="border: 1px solid rgb(223, 223, 223); background: transparent url(chrome://flashblock/content/director.png) no-repeat scroll center; overflow: hidden; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; min-width: 32px; min-height: 32px; width: 224px; height: 280px; cursor: pointer; -moz-box-sizing: border-box;"></div> 

</p><p>
Were your guesses correct? If not, you probably haven't played enough pool :) With our code
from the last article, all three cases would have yielded results identical to Case 3, since
we never took the angle of the collision into account (did you notice the varying angles of
the red line at the time of the collisions).

</p><h4><font color="#cc0000" face="Verdana, Arial, Geneva, Helvetica, sans-serif">Enough concepts, show me the code!</font></h4>

<p>
We'll start out with the same code we used in Part 1 of the article, but as we have just seen
the angle between the two particles must be taken into account when trying to determine the
final velocities. To calculate that angle we will use the position information of each
particle, so two lines are added to the reportInformation handler of the collision behavior:

</p><p>
</p><pre><font color="#cc0000">add tempList, x
add tempList, y
</font></pre>

<p>
Since this information is then passed along to the dealWithCollision handler (the handler that
determines the final velocities) I add several lines to pull the new information out of the
list

</p><p>
</p><pre><font color="#cc0000">set x1 = getat(infoList1,4)
set y1 = getat(infoList1,5)
set x2 = getat(infoList2,4)
set y2 = getat(infoList2,5)
</font></pre>

<p>
and then proceed to find the collision angle (often called phi) using the arc tangent function

</p><p>
</p><pre><font color="#cc0000">set dx = x2-x1
set dy = y2-y1
if dx = 0. then
  set phi = pi()/2.
else
  set phi = atan(dy/dx)
end if
</font></pre>

<p>
Since pictures are often worth a thousand words I present Figure 1 which shows two particles
at the time of collision. The angle names used in the Lingo are show in terms of the Greek
symbols used in the figure.

</p><p>
<img src="collison%20equations%20in%202d_files/figure1.gif" alt="" border="0" height="253" width="431">

</p><p>
At this point, we have the x- and y- velocity components of each puck, but we will also need
the magnitude of the velocity of each puck (shown as the velocity vectors in Figure 1), and
the angle of motion (relative to the standard x-y axes) for each puck. I add several more
lines of code to the dealWithCollision handler to calculate these values:

</p><p>
</p><pre><font color="#cc0000">set term = pi()/180. 
-- used for angle to radian conversions
set v1i = sqrt(v1ix*v1ix+v1iy*v1iy)
set v2i = sqrt(v2ix*v2ix+v2iy*v2iy)
set ang1 = findAnAngle(v1ix,v1iy)*term
set ang2 = findAnAngle(v2ix,v2iy)*term
</font></pre>

<p>
where the findAnAngle handler returns the angle (in degrees) by using the x and y velocity
values:

</p><p>
</p><pre><font color="#cc0000"><b>on findAnAngle xthing,ything</b>

  -- very basic angle finder..returns value in degrees
  -- my mind likes degrees, Director likes radians
  
  set term = pi()/180.
  
  if xthing &lt; 0. then
    set t = 180.+ atan(ything/xthing)/term
  else if xthing &gt; 0. and ything &gt;= 0. then
    set t = atan(ything/xthing)/term
  else if xthing &gt; 0. and ything &lt; 0. then
    set t = 360.+atan(ything/xthing)/term
  else if xthing = 0. and ything = 0. then
    set t=0.
  else if xthing = 0. and ything &gt;= 0. then
    set t = 90.
  else
    set t = 270.
  end if
  
  return t
  

end
</font></pre>

<h4><font color="#cc0000" face="Verdana, Arial, Geneva, Helvetica, sans-serif">Angles, angles, everywhere....</font></h4>

<p>
Why have we started finding all these angles? When I sat down to write my first collision code
I was a bit confused as to how to calculate the velocities after the collision. 1D is
relatively simple (after years of graduate school), but textbooks seemed to gloss over the 2D
material, and most problems provided so much additional information that going through the
full algebraic solution was never required. I finally found the answer in a used textbook
which I picked up for a dime. In 1954 Robert Becker <sup>1</sup> said, "Newton's Rule (i.e. the
conservation of momentum) applies to the components of velocity resolved along the common
normal surfaces of the colliding bodies at the point of contact. In the case of the two
spheres the velocity components involved are the components resolved along the line of centers
during the contact. Consequently, the components of velocity perpendicular to the line of
centers will be unchanged during the impact."

</p><p>
That statement was the best thing I had seen since sliced bread (although you can see why many
consider physics a tad dreary)! Here is my translation: If you view the collision along the
line between the two spheres, the velocities along that line will undergo momentum
conservation (the same way we calculated the x-components in Part 1), and the velocities
perpendicular to that line won't change. Although my words may seem as confusing as Becker's,
I have the power of multimedia to show you what I mean, along with the snippets of code (from
the dealWithCollision handler) applicable to each picture.

</p><p>
We first want to change our mind set from the standard x-y reference frame, to the new
reference frame where the x-axis lies along the collision line, and the y-axis is
perpendicular to that. The figure shows the new vector components,

</p><p>
<img src="collison%20equations%20in%202d_files/step1.gif" alt="" border="0" height="158" width="406">

</p><p>
and the corresponding code is given by:

</p><p>
</p><pre><font color="#cc0000">-- find the velocities in the new coordinate system
set v1xr = v1i*cos((ang1-phi))
set v1yr = v1i*sin((ang1-phi))
set v2xr = v2i*cos((ang2-phi))
set v2yr = v2i*sin((ang2-phi))
</font></pre>

<p>
We now use the conservation of momentum to determine the new x velocities in our new reference
frame, and the y-components do not change. The figure shows the 'flip-flop' of the
x-velocities,

</p><p>
<img src="collison%20equations%20in%202d_files/step2.gif" alt="" border="0" height="165" width="425">

</p><p>
and you can see that the code sets the final y velocities equal to the initial values after
calculating the final x velocities.

</p><p>
</p><pre><font color="#cc0000">-- find the final velocities in the normal reference frame
-- the x velocities will obey the rules for a 1-D collision
set v1fxr = ((m1-m2)*v1xr+(m2+m2)*v2xr)/(m1+m2)
set v2fxr = ((m1+m1)*v1xr+(m2-m1)*v2xr)/(m1+m2)
-- the y velocities will not be changed
set v1fyr = v1yr
set v2fyr = v2yr
</font></pre>

<p>
We now have the 'after collision' velocities, but we have to transform the components back to
the standard x-y reference frame. In this particular case, the velocity of the red puck was
entirely in the standard y-direction (so our x-velocity in the standard reference frame is
zero).

</p><p>
<img src="collison%20equations%20in%202d_files/step3.gif" alt="" border="0" height="226" width="422">

</p><p>
The relevant code (once again) is very dependent on angles!

</p><p>
</p><pre><font color="#cc0000">-- convert back to the standard x,y coordinates
set v1fx = cos(phi)*v1fxr+cos(phi+pi()/2)*v1fyr
set v1fy = sin(phi)*v1fxr+sin(phi+pi()/2)*v1fyr
set v2fx = cos(phi)*v2fxr+cos(phi+pi()/2)*v2fyr
set v2fy = sin(phi)*v2fxr+sin(phi+pi()/2)*v2fyr
</font></pre>

<p>
We've now found the velocity of each particle after a collision has occurred! As you could
see, angles (along with sines and cosines of many angles) played an important role in the
calculation (for learning more about angles stop by ExploreMath.com). With our new and
improved collision code things are looking pretty good, but one problem still remains - that
of the collision detection (i.e. when exactly should we make the call to the dealWithCollision
handler).

</p><h4><font color="#cc0000" face="Verdana, Arial, Geneva, Helvetica, sans-serif">Collision Detection</font></h4>

<p>
In the previous article we simply looked for the distance between the two objects whenever we
step forward in time. That works equally well in this case, but what happens when particles
are moving rather quickly or slowly? Two things often happen when just checking for the
distances: 1) the particles seem to get stuck together like two things connected by a rubber
band (an "internal collision"), and 2) the particles are moving rather quickly and seem to
pass through each other on the screen without actually colliding.

</p><p>
The first case is due to particles which have slow velocities after a collision (in your code
they are still close together after the collision), and the second case is due to the fact
that you are not checking for separation distances frequently enough. I'll present two
solutions that I have used, and one more which I haven't yet tried, but it should work
(consider it a homework problem).

</p><p>
In order to deal with internal collisions a frame script can be used to check for collisions
(by looking for the distance between two particles) on each exitFrame, deal with the collision
when particles first overlap, and then keep track of which particles have not yet separated.
The first line of my frame script has a list properties (I tend to avoid globals...but they
could just as well be defined elsewhere via globals).

</p><p>
</p><pre><font color="#cc0000">property particleSpriteList, collidingParticleList, ¬
  numberOfParticles
</font></pre>

<p>
The particleSpriteList is a list that contains all the sprites that have the collision script
attached to them, and the collidingParticleList will always keep track of which particles are
currently in contact. The numberOfParticles property is just the total number of sprites with
the collision behavior. On every exitFrame we will now run through all particles with a repeat
loop to see who is touching whom.

</p><p>
I hard code my test distance here (24). You could also use the width of the sprites
when you have particles of varying widths.  If the two particles were in the collidingList 
then remove the pair.
        
</p><p>
</p><pre><font color="#cc0000">on exitFrame

  repeat with i = 1 to numberOfParticles-1
  
    repeat with j = i + 1 to numberOfParticles
    
      set particleA = getat(particleSpriteList,i)
      set particleB = getat(particleSpriteList,j)
      
      -- we now have selected two particles 
      -- to see if they are colliding
      
      if distance(particleA, particleB) &gt; 24.  then

        if getOne(collidingParticleList,[particleA,particleB]) ¬
          &lt;&gt; 0 then
          deleteAt collidingParticleList, getOne( ¬
            collidingParticleList, [particleA,particleB])
        end if
        
      else
      
        -- if the pair is not in the collidingList, add the 
        -- pair and call the collision script
        
        if getOne(collidingParticleList,[particleA,particleB]) ¬
          = 0 then
          add collidingParticleList, [particleA,particleB]
          dealWithCollision(particleA,particleB)
        end if
        
      end if
      
    end repeat
    
  end repeat
  
  go to the frame
  
end
</font></pre>

<p>
For most cases that script seems to work rather well when particles are moving with relatively slow
velocities, but as things begin to move more quickly a few more lines of code are worth
looking at.

</p><p>
Another method I have used (to avoid missed collisions) involves additional changes. In the
collision behavior I select a very small time step (e.g. set dTime to be 0.01), and rather
than just moving the particle once in the exitFrame handler of the collision behavior, I run a
repeat loop over small time increments before the position is actually changed on the computer
screen. The code is now written as...

</p><p>
</p><pre><font color="#cc0000">on exitFrame me

  if myActivity = TRUE then
  
  repeat with i = 1 to 10 

    checkForCollision spriteNum 
    
    -- this will see if I have hit any other sprites
    
  end repeat
  
    set the loc of sprite spriteNum = point(x,y)
    
  end if
  
end
</font></pre>

<p>
The upper limit of the repat loop (10) can be changed to a higher or lower value. 
The higher the value the less likely you are to miss a collision, but the code starts 
to take far longer on the "processing" side. 
    
</p><p>
I rewrite my frame script to a basic on exitFrame:go to the frame statement, and convert that
frame script (the full one above which contained two repeat loops) to a movie handler:

</p><p>
</p><pre><font color="#cc0000"><b>on checkForCollision aNum</b>

  repeat with j = 1 to numberOfParticles
  
    set A = aNum
    set B = getat(particleSpriteList,j)
    particleA = min(A, B) 
    -- need to sort these to avoid (3,2) vs (2,3) collisions
    particleB = max(A, B)
    
    if particleA &lt;&gt; particleB then
    
      if distance(particleA, particleB) &gt; 24.  then
      
        if getOne(collidingParticleList,[particleA,particleB]) ¬
          &lt;&gt; 0 then
          deleteAt collidingParticleList, getOne( ¬
            collidingParticleList,[particleA,particleB])
        end if
        
      else
      
        if getOne(collidingParticleList,[particleA,particleB]) ¬
          = 0 then
          add collidingParticleList, [particleA,particleB]
          dealWithCollision(particleA,particleB)
        end if
        
      end if
      
    end if
    
  end repeat
  
end
</font></pre>

<p>
We only have one repeat loop at this point (rather than the two in the initial script), but
every sprite with the collision behavior calls this on an exitFrame. Also, with this script
the particle will often seem to collide without having touched another particle, since so many
calculations are performed before the stage is refreshed. Adjusting the dTime and the maximum
number of the repeat loop in the collision behavior often lead to a reasonable balance
depending on the initial velocities of your particles.

</p><p>
</p><h4><font color="#cc0000" face="Verdana, Arial, Geneva, Helvetica, sans-serif">And for homework...</font></h4>

<p>
That is the end of the "tested" material that I use for a lot of my fun stuff, but one other
technique (which I've never actually found enough time to test), is to solve for the time at
which a collision (tc)between two particles will occur. If you run this test initially (for
all particles) and find the shortest time, you could then wait until that time arrives (while
particles continue to move at a constant velocity), deal with that collision and perform
calculations to find the next time a collision will occur, sit around waiting for the next
collision time to occur, etc. The figure shows two particles at a chosen time of t = 0, and
the time when a collision would occur.

</p><p>
<img src="collison%20equations%20in%202d_files/homework.gif" alt="" border="0" height="184" width="456">

</p><p>
In the figure above it is easy to look at the initial positions and velocities and realize the
two particles will collide, but trying to determine that fact mathematically is a bit more
difficult. The collision time for a pair of particles (with no acceleration) can be written as

</p><p>
<img src="collison%20equations%20in%202d_files/timeeq.gif" alt="" border="0" height="62" width="260">

</p><p>
where the variables are defined as,

</p><p>
<img src="collison%20equations%20in%202d_files/eqdefs.gif" alt="" border="0" height="116" width="380">

</p><p>
The 1 and 2 subscripts refer to each individual particle, and the 'd' term is the distance
between the two particles when the collision occurs (see figure). The equation for the time of
the collision only gives a real solution if

</p><p>
<img src="collison%20equations%20in%202d_files/valideq.gif" alt="" border="0" height="43" width="334">

</p><p>
so you can see a bit of testing is required when using this method.

</p><h4><font color="#cc0000" face="Verdana, Arial, Geneva, Helvetica, sans-serif">The real world</font></h4>

<p>
Simulating the physical world with a computer language is always a challenge, but when the
final product can be used in the classroom and let that 'virtual light bulb' appear over the
students, it is worth the effort. This article discussed the techniques that I routinely use,
but there are many other methods that could be used for collisional coding. I also didn't
discuss frictional forces acting between particles, rotational motion due to the friction, and
a variety of other 'annoyances' that occur in the real world.

</p><p>
Sample movies are available for download in a <a href="http://director-online.com/howTo/UD_articles/UD105/UD105.hqx">Mac</a> or <a href="http://director-online.com/howTo/UD_articles/UD105/UD105.zip">PC</a> format. These are Director 7 files.

</p><p>
<sup>1</sup> Robert A. Becker, Introduction to Theoretical Mechanics, McGraw-Hill Book Company, 1954.

</p></td>

</tr>

</tbody></table><br clear="all">
</td></tr>

<tr><td><font size="-1">
Raman Pfaff earned his Ph.D. in nuclear physics, spent some time as a professor, but is now
having fun as Director of Multimedia Development for 3MP in Charlottesville, VA. In a recent
dream sequence he was stuck in an infinite repeat loop but decided to see a movie, grab a
latte, and watch a Redwings game instead. He can be reached at <a href="mailto:pfaff@explorescience.com">pfaff@explorescience.com</a>. Feel
free to learn a bit more at <a href="http://www.explorescience.com/" target="_blank">http://www.explorescience.com/</a> 
and <a href="http://www.exploremath.com/" target="_blank">http://www.exploremath.com/</a>
       
</font></td></tr></tbody></table></p>

<p><font size="-1">(This article has been viewed 8045 times.)</font></p>
</center></td></tr></tbody></table>
</center></body></html>