<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
<title>Luke's 2D JavaScript Engine version 1.66</title>
<script src="keys.js" type="text/javascript"></script>
<script src="canvas.js" type="text/javascript"></script>
</head>
<body onkeydown="keydown(event)" onkeyup="keyup(event)">
<!--you MUST pre-load all images used in the game like this, as some browsers do very weird things when new images are called up by javascript.  Also helps stop problems with images not loaidng in time
Also, make sure you have a background div of some sort, over the top, to hide them. (display:none; will also do weird things in my experience in IE)
//-->
<img src="balls/white.gif" alt=""><img src="balls/blue.gif" alt=""><img src="balls/green.gif" alt=""><img src="balls/blue.gif" alt=""><img src="balls/red.gif" alt=""><img src="balls/yellow.gif" alt=""><img src="balls/orange.gif" alt=""><img src="blank.gif" alt=""><img src="balls/black.gif" alt="">
<span id="worldspan"></span>
<span id="canvasspan"></span>
<div id="testspan" style="position:relative; z-index:5;"></div>
<div id="testspan2" style="position:relative; z-index:5;"></div>
<script language="JavaScript" type="text/javascript">
<!--



//polytest 1.65 - collision detection with polys works by interesctions of circles and straight lines.  Works reliably, but is in-efficient.


//coming soon - a larger theoretical poly around the outside of each poly, and testing with circles if the midpoint is inside this larger poly.
//should work, and will hopefully be much faster since less calculations are needed.








var wholeworld= new Array()

//General variables used to define major things in the world

var world=document.getElementById('worldspan');
//gravity, and in which direction (could be used as a cheap wind, like Worms 1)  100 seems to be a nice value
var gravityY=0;
var gravityX=0;
//how much  speed everything retains per loop (fraction)
var friction=1
//time/s per refresh
var timeperloop= 0.02
//essentially fps
var refreshrate;
if (document.all){var IE=true}else{var IE = false}
if(IE){refreshrate=timeperloop*796;}else{refreshrate=timeperloop*1000;}
//velocity retained during collision (as fraction), set to 1 for inelastic collisions
var dampen=1
//most force the user can apply to 'us'
var maxuserforce=20000
var incriment=maxuserforce/10

//the minimum speed anything can have before it's stopped (set to 0 for no min speed)
var minspeed=10

var addtoworld;

function testnameinarray(thisname)
{for (var i5=0;i5<wholeworld.length;i5++)
{if(wholeworld[i5].name == thisname){return i5;}}
return false;}

function entity(state,name,x,y,width,height,mass,image,type,vx,vy,fx,fy,hard,sticky,shape,divoptions,gametype,elastic)
{
var testarray=testnameinarray(name)
if(testarray == false)
{//if this entity isn't already in the world array, add it.....
this.name=name;this.x=x;this.y=y;this.width=width;this.height=height;this.mass=mass;this.image=image;
this.div=name+'div';
//consider using documenty.gEtelkememtbyid?
this.img=name+'img';
//types 0 =moveable entitiy, 1= still object
this.type=type;
//v=veloctity,f=force
this.vx=vx;this.vy=vy;this.fx=fx;this.fy=fy;
//state is used for wether it's alive or dead (out of the world) or whatever 0=dead, 1=alive (in the world), 2= waiting to be brought back, 3 = due for destruction, 4 = due to be reset (white ball)
this.state=state
//sticky types: false means elastic collision, true means all momentum is lost
this.sticky=sticky;
//shapes, 1= rectangle, 0=circle, 2=square/rectangle, but collide as circle, 3 = polygon
this.shape=shape
//can it collide?
this.hard=hard
//game types.  0=border, 1=ball, 2=hole, 3=not part of game
this.gametype=gametype
//how elastic the collisions are 1=fully, 0.5=partially
this.elastic=elastic
//enter our object into the world array
wholeworld.push(this)
this.divoptions=divoptions

if(!testfordiv(this.div) && this.shape!==3)
{addtoworld="<div id=\'"+this.div+"' style='position:absolute;  width:"+this.width+";"+this.divoptions+" height:"+this.height+";  top:"+this.y+"; left:"+this.x+';'
if(this.state!==1){addtoworld+="display:none;"}else{addtoworld+="display:block;"}
addtoworld+="'>";
if(this.image!==false){addtoworld+="<img id='"+this.name+"img' src='"+this.image+"'>";}
addtoworld+="</div>"
world.innerHTML+=addtoworld}

else{//polygon time! :D
this.linelength=new Array();
this.angle=new Array();

var minx=this.x[0];
var maxx=this.x[0];
var miny=this.y[0];
var maxy=this.y[0];

var dx;
var dy;

for(var i=0;i<this.x.length;i++)
{var i2=i+1
if(i2==this.x.length){i2=0;}
//height = z-index, image = colour, width = thickness
DrawLine(this.x[i],this.y[i],this.x[i2],this.y[i2],this.height,this.image,this.width,this.name+'class')

dx=this.x[i2]-this.x[i];
dy=this.y[i2]-this.y[i];
this.angle[i]=getangle(dx,dy)//store angle of the line.

//linelength is the line length squared, because this saves slower square root calculations later on
this.linelength[i]=(this.x[i2]-this.x[i])*(this.x[i2]-this.x[i])+(this.y[i2]-this.y[i])*(this.y[i2]-this.y[i])

if(this.x<minx){minx=this.x}
if(this.x>maxx){maxx=this.x}
if(this.y<miny){miny=this.y}
if(this.y>maxy){maxy=this.y}
}
//these can be used to create a rectangle around the whole polygon, which could be used for very in-precise collision detection to determin if more precise detection is needed or not.
this.maxx=maxx;
this.minx=minx;
this.maxy=maxy;
this.miny=miny;
}

}else{
//....the worldarray already contains something by this name, so update it
wholeworld[testarray].name=name;wholeworld[testarray].x=x*1;wholeworld[testarray].y=y*1;wholeworld[testarray].width=width*1;wholeworld[testarray].height=height*1;wholeworld[testarray].mass=mass*1;wholeworld[testarray].image=image;
wholeworld[testarray].div=name+'div';
wholeworld[testarray].img=name+'img';
wholeworld[testarray].type=type;
wholeworld[testarray].vx=vx;wholeworld[testarray].vy=vy;wholeworld[testarray].fx=fx;wholeworld[testarray].fy=fy;
wholeworld[testarray].state=state
wholeworld[testarray].sticky=sticky;
wholeworld[testarray].shape=shape
wholeworld[testarray].hard=hard
wholeworld[testarray].gametype=gametype
wholeworld[testarray].elastic=elastic
wholeworld[testarray].divoptions=divoptions
wholeworld[testarray].updatediv();
}
//functions
this.kill=kill
this.unkill=unkill
this.plotme=plotme
this.updatediv=updatediv
this.destroy=destroy
}

function testfordiv(id)
{var testme=document.getElementById(id);
if(testme){return true;}else{return false;}}

//here are where objects are created
//NAMES MUST BE UNIQUE

//entity(state,name,x,y,width,height,mass,image,type,vx,vy,fx,fy,hard,sticky,shape,divoptions,gametype,elastic)

//x,y co-ords are for the top left hand corner, div options are standard HTML bits and bobs for the style of the div

//these are for the borders, you'll always want some kind of border (even if invisible) to stop anything being able to leave the screen
/*
var lowerborder=new entity(1,'lowerborder',0,550,1100,50,10,'blank.gif',1,0,0,0,0,true,false,1,'background-color:#804000;',0,1);
var upperborder=new entity(1,'upperborder',0,0,1100,50,10,'blank.gif',1,0,0,0,0,true,false,1,'background-color:#804000;',0,1);
var leftborder=new entity(1,'leftborder',0,0,50,600,10,'blank.gif',1,0,0,0,0,true,false,1,'background-color:#804000;',0,1);
var rightborder=new entity(1,'rightborder',1050,0,50,600,10,'blank.gif',1,0,0,0,0,true,false,1,'background-color:#804000;',0,1);
*/
var borderpoly=new entity(1,'borderpoly',[50,550,550,50],[50,100,600,600],1,1,10,'black',1,0,0,0,0,true,false,3,'',3,1);

//var smallpoly=new entity(1,'smallpoly',[200,500,350,250],[20,300,400,350],1,1,10,'black',1,0,0,0,0,true,false,3,'',3,1);

//var fakeobject=new entity(1,'fakeobject',50,50,1000,500,0,'blank.gif',1,0,0,0,0,false,false,1,'',3,1);

var bg=new entity(1,'bg',00,00,550,550,0,false,1,0,0,0,0,false,false,1,'background-color:white;',3,1);
/*
var pocketimg=new entity(1,'pocketimg',600,300,50,50,100,'balls/black.gif',1,0,0,0,0,false,false,0,'',3,1);
var pocket=new entity(1,'pocket',620,320,10,10,100,'blank.gif',1,0,0,0,0,true,false,0,'',2,1);
*/

var ball=new entity(1,'ball',100,275,50,50,100,'balls/green.gif',0,0,0,0,0,true,false,0,'',1,0.95);

var worms=new Array()

var square=new entity(1,'square',300,275,30,50,100,false,0,0,0,0,0,true,false,1,'border:solid black 1px;',1,0.95);

var aproxmass=100
var giveortake=5

//for polygons entity(state,name,x array,y array,thickness,z-index,mass,colour,type,vx,vy,fx,fy,hard,sticky,shape,ignore,gametype,elastic)

//var polytest=new entity(1,'polytest',[700,500,500,700],[300,300,500,500],1,1,10,'blue',1,0,0,0,0,true,false,3,'',3,1);

var genxs=new Array()
var genys=new Array()

function randompoly()
{
var avglength=100

var startx=50
var finishx=550

var starty=400
var finishy=400

//var genxs=[startx]
//var genys=[starty]

var y=starty

for(var x=startx;x<finishx;x+=Math.random()*avglength)
{
genxs.push(Math.round(x))
genys.push(Math.round(y))
y+=Math.random()*avglength/4-(avglength*(starty/finishy))/8
}

genxs.push(finishx)
genys.push(finishy)

genxs.push(finishx)
genys.push(600)

genxs.push(startx)
genys.push(600)

}
//randompoly()
//var polytest=new entity(1,'polytest',genxs,genys,1,1,10,'blue',1,0,0,0,0,true,false,3,'',3,1);

var testpoly1=new entity(1,'testpoly1',[100,300,200,150],[100,200,400,150],1,1,10,'blue',1,0,0,0,0,true,false,3,'',3,1);

function testbigpoly(radius,oldXs,oldYs,angles)
{
var newXs=new Array();
var newYs=new Array();

var dy;
var dx;

var diffangle;
var diffangle2;

var lineangle1;
var lineangle2;

for(var i=0;i<oldXs.length;i++)
{var i2=i+1;
var i0=i-1;
if(i2==oldXs.length){i2=0;}
if(i0<0){i0=oldXs.length-1;}

/*

(i0)            (i)
X----------------X
                 |
								 |
								 |
								 X (i2)
*/


dx=oldXs[i2]-oldXs[i];
dy=oldYs[i2]-oldYs[i];

//lineangle2=anglelimits(getangle(dx,dy));
lineangle2=getangle(dx,dy)

dx=oldXs[i0]-oldXs[i];
dy=oldYs[i0]-oldYs[i];
//lineangle1=anglelimits(getangle(dx,dy))
lineangle1=getangle(dx,dy)


if(lineangle2>lineangle1){var bigangle=lineangle2;var smallangle=lineangle1;}else{var bigangle=lineangle1;var smallangle=lineangle2;}
diffangle=bigangle-smallangle;

var avgangle=(lineangle1+lineangle2)/2


diffangle2=angles[i2]-angles[i];



alert("angle2="+Math.round(todegrees(lineangle2))+" angle1="+Math.round(todegrees(lineangle1)))
alert(todegrees(avgangle))


//newXs[i2]=oldXs[i2]+Math.cos(angles[i]+diffangle/2)*radius
//newYs[i2]=oldYs[i2]+Math.sin(angles[i]+diffangle/2)*radius


newXs[i]=oldXs[i]+Math.cos(avgangle)*radius
newYs[i]=oldYs[i]+Math.sin(avgangle)*radius

//alert(newXs[i2])


//idea: find obtuse and acute angles, then test a point a short way along half the acute angle to see if it's inside or outside the polygon.  Then a point of the right radius can be placed! 

}

return [newXs,newYs];
}

var testme=testbigpoly(20,testpoly1.x,testpoly1.y,testpoly1.angle)
var testpoly2=new entity(1,'testpoly2',testme[0],testme[1],1,1,10,'red',1,0,0,0,0,true,false,3,'',3,1);


function anglelimits(thisangle)
{if(thisangle>Math.PI){thisangle-=Math.PI}
else if(thisangle<-Math.PI){thisangle+=Math.PI}
return thisangle;}

function buildpolycollides()
{
var radiis=new Array();
//builds up an array of all the different radii of circles in the world.
for(var k=0;k<wholeworld.length;k++)
{if(wholeworld[k].shape==0){addtoifnotin(radiis,wholeworld[k].width)}}

var polys=new Array();
//builds up an array of all the positions of polygons in the world array.
for(var k=0;k<wholeworld.length;k++)
{if(wholeworld[k].shape==3){polys.push(k)}}

for(var p=0;p<polys.length;p++)
{
wholeworld[p].collidexs=new Array();
wholeworld[p].collideys=new Array();

for(var r=0;r<radiis.length;r++)
{
var tempXs=new Array();
var tempYs=new Array();
//somehow build up a new polygon (outside the original polygon) at a distance of this particular radius 

}
}

}


function addtoifnotin(thisarray,thisthing)
{//this adds an element to an array and returns true if it is already not in it. Otherwise if it's already in the array it returns false.
var testin=0;
for(var z=0;z<thisarray.length;z++)
{if(thisarray[z]==thisthing){testin++;}}
if(testin==0){thisarray.push(thisthing);return true;}
else{return false;}}

//random mass - specically designed for pool, but can be used anywhere.  Attempt to remove complete uniformness to create a bit more realism
function randommass(aprox,leeway)
{var themass=aprox+(Math.random()-1)*2*leeway
return Math.round(themass)}


var needredraw=false

function getangle(x,y)
{
if(x<0){theangle=(Math.PI)+(Math.atan(y/x))}
else if(x>0 && y>=0){theangle=Math.atan(y/x)}
else if(x>0 && y < 0){theangle=2*(Math.PI)+Math.atan(y/x)}
else if(x==0 && y == 0){theangle=0}
else if(x==0 && y>=0){theangle=(Math.PI)/2}
else{theangle=3*(Math.PI)/2}

return theangle;
}

function redrawworld()
{world.innerHTML='';
for (i4=0;i4<wholeworld.length;i4++)
{wholeworld[i4].plotme()}}

function updatediv()
{document.getElementById(this.div).style.left=this.x
document.getElementById(this.div).style.top=this.y
document.getElementById(this.div).style.width=this.width
document.getElementById(this.div).style.height=this.height}


function kill()
{this.state=0;
document.getElementById(this.div).style.display='none';}

//brings entity back
function unkill()
{
if(this.shape!==3){
canwepopout=checkforanycollide(this)
if (canwepopout !==false){this.state=2;if(this.name=='us'){canwepopout.vx=100}}else{this.state=1;document.getElementById(this.div).style.display='block';}
this.updatediv();
}
}

function destroy()
{
if(this.shape!==3){
document.getElementById(this.div).style.display='none';
var destroywhom;
for (var i9=0;i9<wholeworld.length;i9++)
{if(wholeworld[i9].name==this.name){destroywhom=i9}}
wholeworld.splice(destroywhom, 1)
}
}


function plotme()
{
if(this.shape!==3){
if(!testfordiv(this.div))
{addtoworld="<div id=\'"+this.div+"' style='position:absolute;  width:"+this.width+";"+this.divoptions+" height:"+this.height+";  top:"+this.y+"; left:"+this.x+";";
if(this.state!==1){addtoworld+="display:none;"}else{addtoworld+="display:block;"}
addtoworld+="'>";
if(this.image!==false){addtoworld+="<img id='"+this.name+"img' src='"+this.image+"'>";}
addtoworld+="</div>"
world.innerHTML+=addtoworld}
}
}
var counter=0;
//loop stuff
var loopme=setInterval('loop()',refreshrate)
function loop()
{
moveus()
replotentities()

switch(needredraw)
{
case true:
redrawworld()
needredraw=false
break;
}
counter++
}

var player=ball

function moveus()
{

if (moveright){player.fx+=incriment; if (player.fx>maxuserforce){player.fx=maxuserforce};}
if (moveleft){player.fx-=incriment; if (player.fx<-maxuserforce){player.fx=-maxuserforce}}
if(!moveright && !moveleft){if (player.fx>0){player.fx-=incriment};if (player.fx<0){player.fx+=incriment}}
if (moveup){player.fy-=incriment; if (player.fy < -maxuserforce){player.fy=-maxuserforce}}
if (movedown){player.fy+=incriment; if (player.fy > maxuserforce){player.fy=maxuserforce}}
if (!moveup && !movedown){player.fy+=incriment*2; if (player.fy > 0){player.fy=0}}

/*
if(moveleft){player.vx=-100;player.fy=-100}
if(moveright){player.vx=100;player.fy=-100}
if(!moveleft && !moveright){player.vx=0;}
*/
//document.getElementById('testspan').innerHTML="ourfx ="+us.fx+" ourfx ="+us.fy+" ourvx ="+us.vx+" ourvy ="+us.vy
}

function updatefps()
{if (timeperloop!==(1/document.gameform.fpsselect.value)){timeperloop=1/document.gameform.fpsselect.value;refreshrate=1000/document.gameform.fpsselect.value;clearInterval(loopme);loopme=setInterval('loop()',refreshrate)}}


var typecounter

//counts how many of a certain type of peice are are in a certain state
function counttype(thistype,thisstate)
{typecounter=0;
for (var k=0;k<wholeworld.length;k++)
{if(wholeworld[k].type == thistype && wholeworld[k].state == thisstate){typecounter++}}
return typecounter;}


//displacement
var currentleft;
var currenttop;
//velocity
var currentvx;
var currentvy;
var newvx
var newvy
//force
var currentfx;
var currentfy;
//acceleration
var ax
var ay

//seconds per loop

var collide;
var collide2;
var ourvx;
var theirvx;
var ourvy;
var theirvy;

var whichdiv;
var ournewvx;
var ournewvy;
var theirnewvx;
var theirnewvy;

var ourleft
var ourright
var ourtop
var ourbottom
var theirleft
var theirright
var theirtop
var theirbottom
var dontcontinue

var diffinx
var diffiny
var collisionangle
var theirspeed
var ourspeed

var ourperpendicularv;
var ourparellelv;
var theirperpendicularv;
var theirparellelv;

var ournewperpendicularv;
var ournewparellelv;
var theirnewperpendicularv;
var theirnewparellelv;

var ouranglebelowx
var theiranglebelowx

var currentlycolliding


function findacceleration(tempforce,tempmass,tempvelocity,tempfriction)
{
var tempa = (tempforce)/tempmass
//attempt at moddeling friction
if(tempvelocity>1){tempa-=tempfriction}
if(tempvelocity<(-1)){tempa+=tempfriction}
return tempa
}



function checkpockets(whattocheck)
{
var testcollide2=checkcollide(whattocheck.x,whattocheck.y,whattocheck.width,whattocheck.height,whattocheck.shape,pocket.x,pocket.y,pocket.width,pocket.height,pocket.shape)
if(testcollide2 == true){

if(whattocheck.name=='us')
{//you've sunk the white
whattocheck.kill()
whattocheck.x=100
whattocheck.y=275
whattocheck.fx=0
whattocheck.fy=0
whattocheck.vx=0
whattocheck.vy=0
whattocheck.unkill()
}else{
//you've sunk something else
whattocheck.kill()
}
//alert(whattocheck.name)
}

}


//IDEA FOR FRICITON, ADD FRICTION TO SPEED, THEN RESLOVE FOR X AND Y VELOCITIES

function replotentities()
{
for (i=0;i<wholeworld.length;i++)
{
if(wholeworld[i].type == 0 && wholeworld[i].state==1)
{
//if type=0 then we're a entity and thus need to be replotted, and we're not dead
ourspeed=Math.sqrt(wholeworld[i].vx*wholeworld[i].vx+wholeworld[i].vy*wholeworld[i].vy)

var ourangle

if(wholeworld[i].vx<0){ourangle=(Math.PI)+(Math.atan(wholeworld[i].vy/wholeworld[i].vx))}
else if(wholeworld[i].vx>0 && wholeworld[i].vy>=0){ourangle=Math.atan(wholeworld[i].vy/wholeworld[i].vx)}
else if(wholeworld[i].vx>0 && wholeworld[i].vy < 0){ourangle=2*(Math.PI)+Math.atan(wholeworld[i].vy/wholeworld[i].vx)}
else if(wholeworld[i].vx==0 && wholeworld[i].vy == 0){ourangle=0}
else if(wholeworld[i].vx==0 && wholeworld[i].vy>=0){ourangle=(Math.PI)/2}
else{ourangle=3*(Math.PI)/2}

var ourspeedfriction=ourspeed*friction

//acceleration of object to be updated; f=ma therefore a=f/m
ax=(wholeworld[i].fx+gravityX*wholeworld[i].mass-wholeworld[i].vx)/wholeworld[i].mass
ay=(wholeworld[i].fy+gravityY*wholeworld[i].mass-wholeworld[i].vy)/wholeworld[i].mass
//v=u+at
newvy=Math.sin(ourangle)*ourspeedfriction+ay*timeperloop
newvx=Math.cos(ourangle)*ourspeedfriction+ax*timeperloop
//wholeworld[i].vy=newvy
//wholeworld[i].vx=newvx
//optimisation, if we're not moving, don't faff about re-plotting our position
if(newvy!==0 || newvx!==0){
// if we're moving really slowly, and there's no force on us, then stop moving.
if(ourspeedfriction <=minspeed && wholeworld[i].fx==0 && wholeworld[i].fy==0 && ax==0 && ay==0){newvx=0;newvy=0;}
//s=ut + 0.5at^2 therefore, new position = old position + ut+1/2at^2
newx=(wholeworld[i].vx*timeperloop+1/2*ax*timeperloop*timeperloop)+wholeworld[i].x
newy=(wholeworld[i].vy*timeperloop+1/2*ay*timeperloop*timeperloop)+wholeworld[i].y

for (i2=0;i2<wholeworld.length;i2++)
{
if(wholeworld[i2].hard==true && i!==i2 && wholeworld[i2].state==1)
{
if(checkcollide(newx,newy,wholeworld[i].width,wholeworld[i].height,wholeworld[i].shape,wholeworld[i2].x,wholeworld[i2].y,wholeworld[i2].width,wholeworld[i2].height,wholeworld[i2].shape,wholeworld[i],wholeworld[i2]))
{//if there is a collision

switch(wholeworld[i].gametype)
{
case 1: if(wholeworld[i2].gametype==2){if(wholeworld[i].name=='us'){wholeworld[i].state=4;}else{wholeworld[i].state=3}};break;
//use this to detect stuff
}


if(wholeworld[i2].sticky==false)
{
if(wholeworld[i].shape==0 && wholeworld[i2].shape==0)
{
wholeworld[i].vx=newvx
wholeworld[i].vy=newvy
collideascircles(wholeworld[i],wholeworld[i2])

}else if(wholeworld[i].shape==3|| wholeworld[i2].shape==3){collidewithpoly(wholeworld[i],wholeworld[i2])}
else
{
collideassquares(wholeworld[i],wholeworld[i2])
}

if(wholeworld[i2].type==0){wholeworld[i2].vx=theirnewvx;wholeworld[i2].vy=theirnewvy}
//newx=wholeworld[i].x;newy=wholeworld[i].y;


//this bit is new (v1.48), the idea is to solve problems when a ball is stuck between two plates, or similar.
var dx=newx-wholeworld[i].x
var dy=newy-wholeworld[i].y
if(checkcollide((newx-dx/4),(newy-dy/4),wholeworld[i].width,wholeworld[i].height,wholeworld[i].shape,wholeworld[i2].x,wholeworld[i2].y,wholeworld[i2].width,wholeworld[i2].height,wholeworld[i2].shape,wholeworld[i],wholeworld[i2])!==true){newx-=dx/4;newy-=dy/4;}
else if(checkcollide((newx-dx/2),(newy-dy/2),wholeworld[i].width,wholeworld[i].height,wholeworld[i].shape,wholeworld[i2].x,wholeworld[i2].y,wholeworld[i2].width,wholeworld[i2].height,wholeworld[i2].shape,wholeworld[i],wholeworld[i2])!==true){newx-=dx/2;newy-=dy/2;}
else if(checkcollide((newx-(dx/4)*3),(newy-(dy/4)*3),wholeworld[i].width,wholeworld[i].height,wholeworld[i].shape,wholeworld[i2].x,wholeworld[i2].y,wholeworld[i2].width,wholeworld[i2].height,wholeworld[i2].shape,wholeworld[i],wholeworld[i2])!==true){newx-=(dx/4)*3;newy-=(dy/4)*3;}
else{newx=wholeworld[i].x;newy=wholeworld[i].y;}

wholeworld[i].vx=newvx
wholeworld[i].vy=newvy

//end of if sticky
}

newvx*=wholeworld[i].elastic
newvy*=wholeworld[i].elastic

//end of there is a collision
}
//end of collidable if statement
}
//end of i2 (collision) loop
}

wholeworld[i].vx=newvx
wholeworld[i].vy=newvy
wholeworld[i].x=newx
wholeworld[i].y=newy

whichdiv=document.getElementById(wholeworld[i].div);
whichdiv.style.left=Math.round(newx);
whichdiv.style.top=Math.round(newy);

//end of if we're moving statement
}

//end of if entity statement
}
//this will attempt to bring back to life anything which couldn't come back because somehting was in the way 
else if(wholeworld[i].state==2){wholeworld[i].unkill()}
else if(wholeworld[i].state==3){wholeworld[i].destroy();}
else if(wholeworld[i].state==4){wholeworld[i].kill();wholeworld[i].x=100;wholeworld[i].y=275;wholeworld[i].fx=0;wholeworld[i].fy=0;wholeworld[i].vx=0;wholeworld[i].vy=0;wholeworld[i].unkill();}
//end of wholeworld loop 
}
//end of replotentities()
}

function update(updateme)
{}


//the 'collide as' functions collide the two objects given to them, 'us' and 'them', and sets the global variables newvy, newvx, theirnewvy and theirnewvx



function collidewithpoly(us,them)
{
//atm all polys are objects so they can't be 'us'

var k=polyline
var k2=k+1
if(k2==them.x.length){k2=0;}

var dy=(them.y[k2]-them.y[k])
var dx=(them.x[k2]-them.x[k])

var ourangle=getangle(us.vx,us.vy)
//ourangle is the angle the direction of the ball makes with the x axis, measured in a clockwise direction, where the angle is between 0 and 360

var lineangle=getangle(dx,dy)
//ourangle is the angle the line makes with the x axis, measured in a clockwise direction, where the angle is between 0 and 360

vectorangle=lineangle-ourangle
//don't ask how long this took to work out.
newvx=Math.cos(ourangle+vectorangle*2)*ourspeed
newvy=Math.sin(ourangle+vectorangle*2)*ourspeed;
}

function collideassquares(us,them)
{

//from an equation I found on the internet (elastic collisons, re-arrengement of the above two equations)
if(them.type == 0){//we're colliding with an entity, so it can also move

//1D collision equations dervived from kinetic energer and conservation of momentum, probably incorrectly applied in a 2D context
newvx=( (us.mass-them.mass)/(us.mass+them.mass))*us.vx+( (2*them.mass)/(us.mass+them.mass) )*them.vx
newvy=( (us.mass-them.mass)/(us.mass+them.mass))*us.vy+( (2*them.mass)/(us.mass+them.mass) )*them.vy
theirnewvx=( (them.mass-us.mass)/(them.mass+us.mass))*them.vx+( (2*us.mass)/(them.mass+us.mass) )*us.vx
theirnewvy=( (them.mass-us.mass)/(them.mass+us.mass))*them.vy+( (2*us.mass)/(them.mass+us.mass) )*us.vy
}else{//they're an object

dontcontinue=0
theirleft=them.x
theirright=them.x+them.width
theirtop=them.y
theirbottom=them.y+them.height
if(us.y>theirtop && us.y<theirbottom && dontcontinue==0  && us.shape !==3){newvx=us.vx*(-1);newvy=us.vy;dontcontinue++;}
if(us.x>theirleft &&us.x<theirright && dontcontinue==0 && us.shape !==3){newvy=us.vy*(-1);newvx=us.vx;dontcontinue++}
if(us.y+us.height>theirtop && us.y+us.height<theirbottom && dontcontinue==0 && us.shape !==3){newvx=us.vx*(-1);newvy=us.vy;dontcontinue++;}
if(us.x+us.width>theirleft && us.x+us.width<theirright && dontcontinue==0 && us.shape !==3){newvy=us.vy*(-1);newvx=us.vx;dontcontinue++}

if(dontcontinue==0 || us.shape ==3)
{
collideascircles()
//alert('inside squares - circles')
}

}

}




function collideascircles(us,them)
{
ourcentrex=us.x+us.width/2
ourcentrey=us.y+us.height/2
theircentrex=them.x+them.width/2
theircentrey=them.y+them.height/2
diffinx=theircentrex-ourcentrex
diffiny=theircentrey-ourcentrey

if(diffinx == 0){collisionangle=0}else{collisionangle=Math.atan(diffiny/diffinx)}

//essentially, momentum is conserved parrellel and perpendicular to the angle of collision
//http://director-online.com/buildArticle.php?id=532 proved immensly useful, and in actual fact, rendered most of 
//my previous work at collisions wasted as I re-wrote a lot of it
if(us.vx<0){ouranglebelowx=(Math.PI)+(Math.atan(us.vy/us.vx))}
else if(us.vx>0 && us.vy>=0){ouranglebelowx=Math.atan(us.vy/us.vx)}
else if(us.vx>0 && us.vy < 0){ouranglebelowx=2*(Math.PI)+(Math.atan(us.vy/us.vx))}
else if(us.vx==0 && us.vy == 0){ouranglebelowx=0}
else if(us.vx==0 && us.vy>=0){ouranglebelowx=(Math.PI)/2}
else{ouranglebelowx=3*(Math.PI)/2}
if(them.vx<0){theiranglebelowx=(Math.PI)+(Math.atan(them.vy/them.vx))}
else if(them.vx>0 && them.vy>=0){theiranglebelowx=Math.atan(them.vy/them.vx)}
else if(them.vx>0 && them.vy < 0){theiranglebelowx=2*(Math.PI)+(Math.atan(them.vy/them.vx))}
else if(them.vx==0 && them.vy == 0){theiranglebelowx=0}
else if(them.vx==0 && them.vy>=0){theiranglebelowx=(Math.PI)/2}
else{theiranglebelowx=3*(Math.PI)/2}

//ourspeed is set earlier
theirspeed=Math.sqrt(them.vx*them.vx+them.vy*them.vy)
ourparellelv=ourspeed*(Math.cos(ouranglebelowx-collisionangle))
ourperpendicularv=ourspeed*(Math.sin(ouranglebelowx-collisionangle))
theirparellelv=theirspeed*(Math.cos(theiranglebelowx-collisionangle))
theirperpendicularv=theirspeed*(Math.sin(theiranglebelowx-collisionangle))
if(them.type == 0){//we're colliding with an entity, so it can also move

ournewparellelv=( (us.mass-them.mass)/(us.mass+them.mass))*ourparellelv+( (2*them.mass)/(us.mass+them.mass) )*theirparellelv
theirnewparellelv=( (them.mass-us.mass)/(them.mass+us.mass))*theirparellelv+( (2*us.mass)/(them.mass+us.mass) )*ourparellelv
newvx=ournewparellelv*(Math.cos(collisionangle))+ourperpendicularv*(Math.cos(collisionangle+(Math.PI/2)))
newvy=ournewparellelv*(Math.sin(collisionangle))+ourperpendicularv*(Math.sin(collisionangle+(Math.PI/2)))
theirnewvx=theirnewparellelv*(Math.cos(collisionangle))+theirperpendicularv*(Math.cos(collisionangle+(Math.PI/2)))
theirnewvy=theirnewparellelv*(Math.sin(collisionangle))+theirperpendicularv*(Math.sin(collisionangle+(Math.PI/2)))

}else{//we're colliding with an object, so it can't move

ournewparellelv=ourparellelv*(-1)
newvx=ournewparellelv*(Math.cos(collisionangle))+ourperpendicularv*(Math.cos(collisionangle+(Math.PI/2)))
newvy=ournewparellelv*(Math.sin(collisionangle))+ourperpendicularv*(Math.sin(collisionangle+(Math.PI/2)))

}
}


function checkforanycollide(collidee)
{//checks to see if specific shape is currently in a collision
for(i5=0;i5<wholeworld.length;i5++)
{

if(wholeworld[i5].type==0 && wholeworld[i5].state==1)
{
var testcollide=checkcollide(collidee.x,collidee.y,collidee.width,collidee.height,collidee.shape,wholeworld[i5].x,wholeworld[i5].y,wholeworld[i5].width,wholeworld[i5].height,wholeworld[i5].shape)
if(testcollide == true){return wholeworld[i5]}
}

}
return false;
}

function checkspecifics(testx,testy,testwidth,testheight,testshape,testname,testobject)
{//checks if a given theoretical shape would collide
for(i5=0;i5<wholeworld.length;i5++)
{
//wholeworld[i5].type==0 && 
if(wholeworld[i5].state==1 && wholeworld[i5].hard && testname!==wholeworld[i5].name)
{
if(checkcollide(testx,testy,testwidth,testheight,testshape,wholeworld[i5].x,wholeworld[i5].y,wholeworld[i5].width,wholeworld[i5].height,wholeworld[i5].shape,testobject,wholeworld[i5]) == true){return wholeworld[i5]}
}

}
return false;
}



var polycollide;

//x,y=topleft coords, w=width,h=height,s=shape
function checkcollide(x1,y1,w1,h1,s1,x2,y2,w2,h2,s2,us,them)
{
rightx1=x1+w1
rightx2=x2+w2
bottomy1=y1+h1
bottomy2=y2+h2
centrex1=x1+w1/2
centrex2=x2+w2/2
centrey1=y1+h1/2
centrey2=y2+h2/2
rad1=h1/2
rad2=h2/2
if(s1==0 && s2==0)
{
//both are circles
radii=Math.pow((rad1+rad2),2);
//pythagoras - this was pythag, but since square roots are slow maths, I've just decided to compare the squares.
var circledistance= (centrex1-centrex2)*(centrex1-centrex2)+(centrey1-centrey2)*(centrey1-centrey2) 
//alert(circledistance) 
//if the distance between the two circles is less than or equal to the sum of their two radii then they'll collide
if(circledistance<radii){return true}
}

//shapes, 1= rectangle, 0=circle, 2=square/rectangle, but collide as circle, 3 = polygon

else if(s1==3 || s2==3)//involves a polygon
{
if(s1==3)
{polycollide=polyandshape(us,x2,y2,them)}
else{polycollide=polyandshape(them,x1,y1,us)}

if(polycollide){return true;}

}
else
{
//circle + rectangle combo
if(rightx1 > x2 && x1 < (x2+w2) && y1 < (y2+h2) && bottomy1 > y2){return true}
}
return false;
}

var polyline

function polyandshape(poly,theirx,theiry,notpoly)
{//detects if there's a collision with a polygon

//this is the third version of this function, the first used vector equations to detect when it will collide, but this never worked.
//the second was very simple, it measured the distance from the shape to each end of the line, and if these two lengths 
//were nearly the same as the length of the line, then it would count as a collisison.  however, this whilst it did work, wasn't very good
//it didn't properly detect collisisons with 'spikey' polygons and left a large buffer for some reason

//this current, hopefully last, version uses an algebraic technicue to find were lines, or circles and lines will intersect.  After some problems with 
//horizontal and vertical line gradients, it was proved very reliable. 

theircentrex=theirx+notpoly.width/2
theircentrey=theiry+notpoly.height/2

for(var k=0;k<poly.x.length;k++)
{//loop through each line of the polygon
k2=k+1
if(k2==poly.x.length){k2=0;}

//var linelength=distance(poly.x[k2],poly.y[k2],poly.x[k],poly.y[k])+0.5



//minus one unit vector from the second pair of co-ords to try and avoid problems on spikey bits



var polyx1=poly.x[k]//+dx*2/linelength
var polyy1=poly.y[k]//+dy*2/linelength
var polyx2=poly.x[k2]//-dx*2/linelength
var polyy2=poly.y[k2]//-dy*2/linelength

//alert(poly.x[k2]+' '+polyx2+' '+(dx/linelength))

//check to see if we're even vaguely near first.  if we are *then* check thoroughly

//this actually compares the squares of the lengths, as this is much faster to execute.
if(Math.pow((theircentrex-polyx2),2)+Math.pow((theircentrey-polyy2),2)+Math.pow((theircentrex-polyx1),2)+Math.pow((theircentrey-polyy1),2) <= poly.linelength[k]+Math.pow((notpoly.width+notpoly.height),2))
{




var dy=poly.y[k2]-poly.y[k]
var dx=poly.x[k2]-poly.x[k]

if(polyx1<polyx2){var testpolyx1=polyx1;var testpolyx2=polyx2}else{var testpolyx1=polyx2;var testpolyx2=polyx1}
if(polyy1<polyy2){var testpolyy1=polyy1;var testpolyy2=polyy2}else{var testpolyy1=polyy2;var testpolyy2=polyy1}

if(notpoly.shape!==0)//check all four corners of rectangle
{
var leftx=theirx
var topy=theiry
var rightx=theirx+notpoly.width
var bottomy=theiry+notpoly.height
//top line of square
if(linesintersect(leftx,topy,rightx,topy,polyx1,polyy1,polyx2,polyy2)){polyline=k;return true}
//right hand side
if(linesintersect(rightx,topy,rightx,bottomy,polyx1,polyy1,polyx2,polyy2)){polyline=k;return true}
//bottom line
if(linesintersect(leftx,bottomy,rightx,bottomy,polyx1,polyy1,polyx2,polyy2)){polyline=k;return true}
//left had side
if(linesintersect(leftx,topy,leftx,bottomy,polyx1,polyy1,polyx2,polyy2)){polyline=k;return true}
}else{//circle intersecting with a line
var r=notpoly.width/2
var a=theircentrex
var b=theircentrey
var x1=polyx1
var y1=polyy1
//gradient of poly line
var m=dy/dx

switch(m)
{

case Infinity:
case -Infinity:
//vertical line - we know x, but have potentially two possible Ys
var x=x1
//b^2 - 4ac
var discrim=Math.pow((-2*b),2)-4*(b*b+(x-a)*(x-a)-r*r)
if(discrim>=0)
{//minus
var y=(-(-2*b)-Math.sqrt(discrim))/2
if(testpolyx1<=x && x<= testpolyx2 && testpolyy1<=y && y<=testpolyy2){polyline=k;return true}
//plus
var y=(-(-2*b)+Math.sqrt(discrim))/2
if(testpolyx1<=x && x<= testpolyx2 && testpolyy1<=y && y<=testpolyy2){polyline=k;return true}
}

break;
case 0:
//horizontal line, two potential Xs
var y=y1
var discrim=Math.pow((-2*a),2)-4*(a*a+(y-b)*(y-b)-r*r)
if(discrim>=0)
{//minus
var x=(-(-2*a)-Math.sqrt(discrim))/2
if(testpolyx1<=x && x<= testpolyx2 && testpolyy1<=y && y<=testpolyy2){polyline=k;return true}
//plus
var y=(-(-2*a)+Math.sqrt(discrim))/2
if(testpolyx1<=x && x<= testpolyx2 && testpolyy1<=y && y<=testpolyy2){polyline=k;return true}
}

break;

default:
//re-arrangement of the equation of a circle and the equation of a straight line to find the x co-ordinate of an intersection
var discrim=Math.pow((-2*a-2*m*m*x1+2*y1*m-2*b*m),2)-4*(1+m*m)*(-2*m*x1*y1+2*m*x1*b+m*m*x1*x1-r*r+a*a+(y1-b)*(y1-b))
//if discriminant is less than zero then there are no real roots and :. no interesction
if(discrim>=0)
{//circle intersects line, but where?
//minus first
var x=(-(-2*a-2*m*m*x1+2*y1*m-2*b*m)-Math.sqrt(discrim))/(2*(1+m*m))
var y=m*(x-x1)+y1
if(testpolyx1<=x && x<= testpolyx2 && testpolyy1<=y && y<=testpolyy2){polyline=k;return true}
//then plus
x=(-(-2*a-2*m*m*x1+2*y1*m-2*b*m)+Math.sqrt(discrim))/(2*(1+m*m))
y=m*(x-x1)+y1
if(testpolyx1<=x && x<= testpolyx2 && testpolyy1<=y && y<=testpolyy2){polyline=k;return true}
//end of discrim if
}

break;
//end of m switch
}




//end of circle if
}
//end of optimisation if
}
//end of loop
}
return false
}

function linesintersect(sx1,sy1,sx2,sy2,px1,py1,px2,py2)
{
/*var sdx=sx2-sx1
var sdy=sy2-sy1
var pdx=px2-px1
var pdy=py2-py1*/
//gradients s=shape, p=poly





if(sx1<sx2){var sx1test=sx1;var sx2test=sx2}else{var sx1test=sx2;var sx2test=sx1;}
if(sy1<sy2){var sy1test=sy1;var sy2test=sy2}else{var sy1test=sy2;var sy2test=sy1;}
if(px1<px2){var px1test=px1;var px2test=px2}else{var px1test=px2;var px2test=px1;}
if(py1<py2){var py1test=py1;var py2test=py2}else{var py1test=py2;var py2test=py1;}


//if(sx2 > px1 && sx1 < px2 && sy1 < py2 && sy2 > py1){

var sm=(sy2-sy1)/(sx2-sx1)
var pm=(py2-py1)/(px2-px1)

//gradients not equal :. not parallel and will intersect in 2D
if(sm!==pm && sm!==Infinity && pm!==Infinity && sm!==0 && pm!==0)
{
//co-ords of intersection
var x=(sx1*sm-px1*pm+py1-sy1)/(sm-pm)
var y=pm*(x-px1)+py1

}else{
//an infinite gradient means a vertical line
if(sm==-Infinity){sm=Infinity}
if(pm==-Infinity){pm=Infinity}
//a gradient of zero means a horizontal line

if(sm==Infinity && pm==Infinity){if(sy2test>=py1test && sy1test<=py2test && sx1==px1){return true}}
else if(sm==0 && pm==0){if(sx2test>=px1test && sx1test<=px2test && py1==sy1){return true}}
else if(sm==Infinity && pm==0){var x=sx1;var y=py1;}
else if(sm==0 && pm==Infinity){var y=sy1;var x=px1;}
else if(sm==Infinity){var x=sx1;var y=pm*(x-px1)+py1}
else if(pm==Infinity){var x=px1;var y=sm*(x-sx1)+sy1}
else if(sm==0){var y=sy1;var x=(y-py1)/pm+px1}
else if(pm==0){var y=py1;var x=(y-sy1)/sm+sx1}

}

//alert(Math.round(x)+','+Math.round(y))
if(sx1test<=x && x<=sx2test && px1test<= x && x<=px2test && sy1test<=y && y<=sy2test && py1test<=y && y<=py2test){return true}


//end of optimisation
//}

return false;
}

function toradians(degrees)
{return ((Math.PI/180)*degrees)}

function todegrees(radians)
{return ((radians/Math.PI)*180)}

function distance(dx1,dy1,dx2,dy2)
{

var dx=dx2-dx1
var dy=dy2-dy1

return Math.sqrt(dx*dx+dy*dy)
}
//-->
</script>

</body>
</html>


